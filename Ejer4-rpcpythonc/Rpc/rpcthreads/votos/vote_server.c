/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "vote.h"
#include <unistd.h>
typedef enum {SERVERFAILURE, NOERROR, WRONG_ID, ALRVOTED}ERRORS; 

typedef struct tag_voter {
	int id;
	int voted;
} Voter;
int number_of_voters;
int number_of_candidates;
char **cand_names;
char temp_line[80];
mutex_t vote_sem;

void initialize(void)
{
	FILE *cands;
	FILE *fVoters, *fVotersTxt, *fVotes;
	Voter v;
	int i=0;
	/* read candidates from file */
	if ( (cands = fopen("candidates","r")) == NULL){
		fprintf(stderr,"candidates file does not exists\n");
		exit(1);
	}

	mutex_init(&vote_sem, USYNC_THREAD, NULL);

	fscanf(cands, "%d\n", &number_of_voters);
	fscanf(cands, "%d\n", &number_of_candidates);
	
	cand_names = (char **) malloc(number_of_candidates*sizeof(char *));
	while ( fgets(temp_line, 80, cands) != NULL){
		cand_names[i] = (char *) malloc((strlen(temp_line))*sizeof(char));
		temp_line[strlen(temp_line)-1] = '\0';
		strcpy(cand_names[i], temp_line);
		i++;
	} 
	
	fclose(cands);
	
	fVoters = fopen("voters", "rb");	
	if (fVoters != NULL)
	  	fclose(fVoters);
	else {
	  	fVotersTxt = fopen("voters.txt","w");
	  	fVoters = fopen("voters", "wb");
	  	srand(time(NULL));
	  	v.voted = 0;
	
	  	for (i = 0; i < number_of_voters; i++) {
	    		v.id = i*10000 + rand()%10000;
	    		fprintf(fVotersTxt, "%d:\t%8d\n", i, v.id);
	    		fwrite(&v, sizeof(Voter), 1, fVoters);
	  	}
	  	fclose(fVoters);
	  	fclose(fVotersTxt);
	  
	}
	  
	
	fVotes = fopen("votes", "rb");	
	if (fVotes != NULL)
	  	fclose(fVotes);
	else {
        	int j=0;
	
        	fVotes = fopen("votes", "wb");


	 	fwrite(&j, sizeof(int), 1, fVotes);
	 	
	  	for (i = 0; i < number_of_candidates; i++) 	    
          		fwrite(&j, sizeof(int), 1, fVotes);
	  
	  	fclose(fVotes);
 
	}
}
bool_t
results_1_svc(void *argp, lineptr *result, struct svc_req *rqstp)
{
        bool_t retval = TRUE;
        static line temp2;

        int i,j,total_votes;
        char temp[90];
	char mparitsa[22];
	FILE *fVotes;
	int v;
	float pc = 0.0;
	if((fVotes = fopen("votes", "rb+"))==NULL){
		sprintf(temp2,"Server failure\n");
		*result = &temp2;
		return retval;
	}
	fread(&total_votes ,sizeof(int), 1, fVotes);
	sprintf(temp2,"Voted: %d\n\n"
	              "ID Name            \t   Votes       %%\n",
	total_votes);	
        for (i = 0; i < number_of_candidates; i++){
		fread(&v,sizeof(int), 1, fVotes);
		if (total_votes == 0) 
			pc = 0;
		else pc = ((float) v/total_votes);

		for (j = 0; j< pc * 20; j++)
			mparitsa[j] = '*';
		for(;j<20;j++)
			mparitsa[j] = ' ';
		mparitsa[20] = '|';
		mparitsa[21] = '\0';
			
                sprintf(temp, "%d. %s \t %5d    %7.1f%%\t|%s\n", i+1,
cand_names[i],v, pc*100, mparitsa);		
                strcat(temp2, temp);
        }
	fclose(fVotes);
/*         
	fprintf(stderr,"start\n");
	{
	 	long int blakas;
		for (blakas = 0 ; blakas < 100000000; blakas++);
		fprintf(stderr,"teliwsa\n");
	
	}
	printf("end\n");
*/
	*result = &temp2;
	return retval;
}


bool_t
vote_1_svc(ARGS1 *argp, int *result, struct svc_req *rqstp)
{
        bool_t retval = TRUE;
	FILE *fVotes, *fVoters;
	int v;
	Voter voter;
	int voter_id;
	
	mutex_lock(&vote_sem);
	voter_id = argp->myid/10000;
	if((fVoters = fopen("voters", "rb+"))==NULL){
		*result=	SERVERFAILURE;
		mutex_unlock(&vote_sem);
		return retval;
	}
	fseek(fVoters,voter_id*sizeof(Voter),SEEK_SET);
	fread(&voter,sizeof(Voter), 1, fVoters);
	if (voter.id != argp->myid){
		*result = WRONG_ID;
		mutex_unlock(&vote_sem);
		return retval;
	}
	if (voter.voted) {
		*result = ALRVOTED;
		mutex_unlock(&vote_sem);
		return retval;
	}
	voter.voted = 1;
	fseek(fVoters,-sizeof(Voter),SEEK_CUR);
	fwrite(&voter,sizeof(Voter), 1, fVoters);
	fclose(fVoters);

	if(argp->candidate>number_of_candidates || argp->candidate<1){
		*result=WRONG_ID;
		mutex_unlock(&vote_sem);
		return retval;
	}
	if((fVotes = fopen("votes", "rb+"))==NULL){
		*result=	SERVERFAILURE;
		mutex_unlock(&vote_sem);
		return retval;
	}
	fread(&v,sizeof(int), 1, fVotes);
	v++;
	printf("v=%d\n",v);
	rewind(fVotes);
	fwrite(&v,sizeof(int), 1, fVotes);
	fseek(fVotes,argp->candidate*sizeof(int),SEEK_SET);
	fread(&v,sizeof(int), 1, fVotes);
	v++;
	fseek(fVotes,-sizeof(int),SEEK_CUR);
	fwrite(&v,sizeof(int), 1, fVotes);
	fclose(fVotes);
	  
	*result=NOERROR;
	
	if (voter_id == 9 || voter_id==8) {
	 	long int blakas;
		for (blakas = 0 ; blakas < 100000000; blakas++);
	
	}	
	mutex_unlock(&vote_sem);
	return retval;
}


bool_t
candidates_1_svc(void *argp, ARGS2 *result, struct svc_req *rqstp)
{
        bool_t retval = TRUE;
	
        int i;
        char temp[90];
	

	
	
        result->numofcandidates = number_of_candidates;
	result->candidatelist[0]='\0';
        for (i = 0; i < number_of_candidates; i++){
                sprintf(temp, "%d: %s\n", i+1, cand_names[i]);
                strcat(result->candidatelist, temp);
        }
	return retval;
}



/* mistiriwdi sinartisi*/
int
vote_system_1_freeresult(SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
        (void) xdr_free(xdr_result, result);

        /*
         * Insert additional freeing code here, if needed
         */


        return (TRUE);
}